rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ========================================
    // Helper Functions
    // ========================================
    
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Get user's role in a specific feed
    function getMemberData(feedId) {
      return get(/databases/$(database)/documents/feeds/$(feedId)/members/$(request.auth.uid)).data;
    }

    // Check if user is a member of a feed
    function isMember(feedId) {
      return exists(/databases/$(database)/documents/feeds/$(feedId)/members/$(request.auth.uid));
    }

    // Check if user has a specific role in a feed
    function hasRole(feedId, role) {
      return isMember(feedId) && getMemberData(feedId).role == role;
    }

    // Check if user is admin or moderator
    function isAdminOrMod(feedId) {
      return isMember(feedId) && getMemberData(feedId).role in ['admin', 'moderator'];
    }

    // Check if a feed is public
    function isPublicFeed(feedId) {
      return get(/databases/$(database)/documents/feeds/$(feedId)).data.visibility == 'public';
    }

    // Check if a feed is a personal feed
    function isPersonalFeed(feedId) {
      return feedId.matches('personal_.*');
    }

    // Check if user owns a personal feed
    function ownsPersonalFeed(feedId) {
      return feedId == 'personal_' + request.auth.uid;
    }

    // Validate flip document structure
    function isValidFlipData() {
      return request.resource.data.keys().hasAll(['feedIds', 'authorId', 'createdAt'])
        && request.resource.data.authorId == request.auth.uid
        && request.resource.data.feedIds is list
        && request.resource.data.feedIds.size() > 0;
    }

    // ========================================
    // Collection: users
    // ========================================
    match /users/{userId} {
      // Anyone authenticated can read user profiles
      allow get: if isAuthenticated();
      
      // List users with pagination (for search/discovery)
      allow list: if isAuthenticated();
      
      // Users can create their own profile (via userFlows)
      allow create: if isAuthenticated() && isOwner(userId);
      
      // Users can update their own profile
      allow update: if isAuthenticated() && isOwner(userId);
      
      // Users cannot delete their profile (use functions/genkit flows)
      allow delete: if false;

      // Sub-collection: usernameHistory (immutable audit log)
      match /usernameHistory/{historyId} {
        allow read: if isAuthenticated() && isOwner(userId);
        allow create: if isAuthenticated() && isOwner(userId);
        allow update, delete: if false; // Username history is immutable
      }

      // Sub-collection: feeds (reverse lookup - user's joined feeds)
      match /feeds/{feedId} {
        // Users can read their own feed memberships
        allow read: if isAuthenticated() && isOwner(userId);
        
        // Only backend flows can write (createFeedFlow, joinFeedFlow)
        allow write: if false;
      }

      // Document: personalFeed reference
      match /personalFeed {
        allow read: if isAuthenticated() && isOwner(userId);
        allow write: if false; // Only backend on user creation
      }
    }

    // ========================================
    // Collection: feeds
    // ========================================
    match /feeds/{feedId} {
      // Personal Feeds: Only owner can read
      allow get: if isPersonalFeed(feedId) && ownsPersonalFeed(feedId);
      
      // Regular Feeds: Public feeds readable by anyone, private by members only
      allow get: if !isPersonalFeed(feedId) 
                   && isAuthenticated() 
                   && (isPublicFeed(feedId) || isMember(feedId));
      
      // List feeds (for discovery)
      // Client must filter by visibility='public' in query
      allow list: if isAuthenticated() 
                    && (request.query.limit == null || request.query.limit <= 50); // Prevent large queries

      // Create feeds via backend flows only (createFeedFlow)
      allow create: if false;
      
      // Update feed metadata: Only admins
      allow update: if isAuthenticated() 
                      && !isPersonalFeed(feedId)
                      && hasRole(feedId, 'admin')
                      && request.resource.data.owner == resource.data.owner; // Cannot change owner
      
      // Delete feeds: Only admins
      allow delete: if isAuthenticated() 
                      && !isPersonalFeed(feedId)
                      && hasRole(feedId, 'admin');

      // Sub-collection: members
      match /members/{memberId} {
        // Members can read the member list
        allow get, list: if isAuthenticated() && isMember(feedId);
        
        // Create memberships via backend flows only (joinFeedFlow)
        allow create: if false;
        
        // Update member roles: Only admins (cannot promote yourself)
        allow update: if isAuthenticated() 
                        && hasRole(feedId, 'admin')
                        && memberId != request.auth.uid;
        
        // Delete membership:
        // - User can leave (delete own membership)
        // - Admins can remove others (but not themselves)
        allow delete: if isAuthenticated() 
                        && (memberId == request.auth.uid || (hasRole(feedId, 'admin') && memberId != request.auth.uid));
      }
    }

    // ========================================
    // Collection: flips
    // ========================================
    match /flips/{flipId} {
      // Helper to check if user can view a flip
      function canViewFlip() {
        let feedIds = resource.data.feedIds;
        // This is a simplified check. A robust implementation might require a function
        // that checks membership for each feedId, which isn't possible directly.
        // We rely on the client querying correctly and backend validation.
        // For direct gets, we check if the user is a member of the *first* feed.
        // This is a limitation of Firestore rules. A better check is done on list queries.
        return isMember(feedIds[0]) || isPublicFeed(feedIds[0]);
      }

      // Read individual flips if user is a member of any associated feed
      allow get: if isAuthenticated() && canViewFlip();
      
      // List flips (must query with 'array-contains' on a feedId the user is in)
      allow list: if isAuthenticated()
                    && (request.query.limit == null || request.query.limit <= 100);
                    
      // Create flips: Let backend flows handle validation.
      // Rule ensures data is well-formed.
      allow create: if isAuthenticated() && isValidFlipData();

      // Update flips: Only the author (for editing title, etc.)
      // For now, feedIds cannot be changed after creation.
      allow update: if isAuthenticated() 
                      && isOwner(resource.data.authorId)
                      && request.resource.data.feedIds == resource.data.feedIds
                      && request.resource.data.authorId == resource.data.authorId;
      
      // Delete flips: Author, or feed admin/moderator of any associated feed.
      // This check is simplified and may need a backend flow for accuracy.
      allow delete: if isAuthenticated() 
                      && (isOwner(resource.data.authorId) || isAdminOrMod(resource.data.feedIds[0]));

      // Sub-collection: comments
      match /comments/{commentId} {
        // Read comments if you can read the flip
        allow get, list: if isAuthenticated() && canViewFlip();
        
        // Create comments: Members of the feed only
        allow create: if isAuthenticated() && isMember(resource.data.feedIds[0]);
        
        // Update comments: Only the author
        allow update: if isAuthenticated() && isOwner(request.resource.data.authorId);
        
        // Delete comments: Author, or feed admin/moderator
        allow delete: if isAuthenticated() 
                        && (isOwner(resource.data.authorId) || isAdminOrMod(resource.data.feedIds[0]));
      }

      // Sub-collection: likes (future feature)
      match /likes/{likeId} {
        allow read: if isAuthenticated() && canViewFlip();
        allow create: if isAuthenticated() && isMember(resource.data.feedIds[0]) && likeId == request.auth.uid;
        allow delete: if isAuthenticated() && isOwner(likeId);
      }
    }

    // ========================================
    // Collection: friendships
    // ========================================
    match /friendships/{friendshipId} {
      // Read individual friendship if user is a participant
      allow get: if isAuthenticated() 
                   && request.auth.uid in resource.data.users;

      // List friendships - query filters by array-contains
      allow list: if isAuthenticated();

      // Create friendships if user is the requester and a participant
      allow create: if isAuthenticated() 
                      && request.auth.uid == request.resource.data.requesterId 
                      && request.auth.uid in request.resource.data.users;

      // Update friendships if user is a participant (accepting, etc.)
      allow update: if isAuthenticated() 
                      && request.auth.uid in resource.data.users;

      // Delete friendships if user is a participant
      allow delete: if isAuthenticated() 
                      && request.auth.uid in resource.data.users;
    }

    // ========================================
    // Collection: invites (future feature)
    // ========================================
    match /invites/{inviteId} {
      // Read invite if you're the inviter or invitee
      allow get: if isAuthenticated()
                   && (request.auth.uid == resource.data.inviterId || request.auth.uid == resource.data.inviteeId);
      // List invites for a user
      allow list: if isAuthenticated();
      
      // Create invites if you're an admin/mod of the feed
      allow create: if isAuthenticated()
                      && isAdminOrMod(request.resource.data.feedId);
      
      // Update invites (accept/decline)
      allow update: if isAuthenticated()
                      && request.auth.uid == request.resource.data.inviteeId;
      
      // Delete invites
      allow delete: if isAuthenticated()
                      && (request.auth.uid == request.resource.data.inviterId || request.auth.uid == request.resource.data.inviteeId);
    }

    // ========================================
    // Collection: flipLinks (future feature - viral sharing)
    // ========================================
    match /flipLinks/{linkId} {
      // Anyone can read flipLinks (public sharing mechanism)
      allow get: if true;
      
      // List flipLinks is not allowed (prevents enumeration)
      // Omitted rule defaults to deny
      
      // Create flipLinks if you're a member of the feed
      allow create: if isAuthenticated()
                      && isMember(request.resource.data.feedId);
      
      // Update/delete only by creator
      allow update, delete: if isAuthenticated()
                              && isOwner(request.resource.data.creatorId);
    }

    // ========================================
    // Deny all other paths
    // ========================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

