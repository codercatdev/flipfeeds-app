FlipFeeds: Core Firestore Data SchemaThis schema is designed for a multi-tenant system where "Feeds" are the tenants. All paths should be constants in your code.We will use a version field (e.g., v1) on top-level collections to make future schema migrations easier.1. Collection: usersStores public-facing user profile data and private user-specific info.Path: v1/users/{userId}{userId} will be the Firebase Auth UID.Document ({userId}):{
  "uid": "fbas_auth_uid",
  "email": "user@example.com", // From Auth, can be private
  "displayName": "UserName",
  "photoURL": "[https://path.to/avatar.png](https://path.to/avatar.png)", // User's main avatar
  "username": "username_handle", // Unique, public-facing @handle
  "bio": "About me...",
  "createdAt": "FirebaseServerTimestamp",
  "updatedAt": "FirebaseServerTimestamp",
  "settings": {
    "theme": "dark",
    "notifications": {
      "pushEnabled": true,
      "emailEnabled": false
    }
  },
  "fcmTokens": ["token1", "token2"] // For push notifications
}
2. Collection: feedsStores all Circle data. This is the central collection.Path: v1/feeds/{feedId}{feedId} will be a unique ID generated by Firestore.Document ({feedId}):{
  "name": "My Cool Next.js Feed",
  "description": "A place to share videos about Next.js and Firebase.",
  "logoURL": "[https://path.to/feed-logo.png](https://path.to/feed-logo.png)", // The orange logo
  "bannerURL": "[https://path.to/feed-banner.png](https://path.to/feed-banner.png)",
  "visibility": "public" | "private", // 'public' = discoverable, 'private' = invite-only
  "ownerId": "userId_of_owner", // Ref to v1/users/{userId}
  "stats": {
    "memberCount": 150,
    "postCount": 45
  },
  "createdAt": "FirebaseServerTimestamp",
  "updatedAt": "FirebaseServerTimestamp",
  "tags": ["nextjs", "firebase", "react", "genkit"] // For discoverability
}
3. Sub-Collection: feedMembersTracks the relationship between users and feeds. This is critical for security rules.Path: v1/feeds/{feedId}/members/{userId}This structure allows us to easily check if a user is in a feed.Document ({userId}):{
  "userId": "fbas_auth_uid",
  "role": "admin" | "moderator" | "member",
  "joinedAt": "FirebaseServerTimestamp",
  "displayName": "UserName", // Denormalized for easy display
  "photoURL": "[https://path.to/avatar.png](https://path.to/avatar.png)" // Denormalized
}
Note: We also need a reverse lookup.4. Sub-Collection: userFeedsA reverse-lookup collection to quickly find all feeds a user is in.Path: v1/users/{userId}/feeds/{feedId}This allows a user to see their list of "My Feeds" without a complex query.Document ({feedId}):{
  "feedId": "feedId_from_feeds_collection",
  "joinedAt": "FirebaseServerTimestamp",
  "role": "admin" | "moderator" | "member",
  "name": "My Cool Next.js Feed", // Denormalized
  "logoURL": "[https://path.to/feed-logo.png](https://path.to/feed-logo.png)" // Denormalized
}
5. Collection: postsStores all posts (primarily videos) for all feeds. We use a root-level collection and query by feedId for scalability.Path: v1/posts/{postId}Document ({postId}):{
  "feedId": "feedId_of_parent", // **Indexed field for querying**
  "authorId": "userId_of_author",
  "authorInfo": { // Denormalized for display
    "displayName": "UserName",
    "photoURL": "[https://path.to/avatar.png](https://path.to/avatar.png)"
  },
  "type": "video" | "text" | "image",
  "title": "My First Video Post!",
  "textContent": "Check this out...", // For text-only posts
  "createdAt": "FirebaseServerTimestamp",
  "updatedAt": "FirebaseServerTimestamp",
  "media": {
    "video": {
      "storagePath": "videos/{feedId}/{postId}/video.mp4",
      "url": "[https://firebasestorage.googleapis.com/](https://firebasestorage.googleapis.com/)...", // Public URL
      "durationMs": 120000
    },
    "thumbnail": {
      "storagePath": "videos/{feedId}/{postId}/thumb.jpg",
      "url": "[https://firebasestorage.googleapis.com/](https://firebasestorage.googleapis.com/)..."
    }
  },
  "aiData": {
    "summary": "This video shows how to use Genkit with Firebase.",
    "isModerated": true,
    "moderationFlags": [],
    "tags": ["genkit", "firebase"]
  },
  "stats": {
    "likeCount": 10,
    "commentCount": 5
  }
}
6. Sub-Collection: commentsComments for a specific post.Path: v1/posts/{postId}/comments/{commentId}Document ({commentId}):{
  "postId": "postId_of_parent",
  "authorId": "userId_of_author",
  "authorInfo": { // Denormalized
    "displayName": "UserName",
    "photoURL": "[https://path.to/avatar.png](https://path.to/avatar.png)"
  },
  "textContent": "Great video!",
  "createdAt": "FirebaseServerTimestamp",
  "updatedAt": "FirebaseServerTimestamp"
}
FlipFeeds: Core Firebase Security RulesThis is a foundational firestore.rules file. It's critical for securing your multi-tenant data.This is a starting point and MUST be tested thoroughly with the Firebase Emulator Suite.rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user is the owner of a document
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Get user's role in a specific feed
    function getRole(feedId) {
      return get(/databases/$(database)/documents/v1/feeds/$(feedId)/members/$(request.auth.uid)).data.role;
    }

    // Check if user is a member of a feed
    function isMember(feedId) {
      return exists(/databases/$(database)/documents/v1/feeds/$(feedId)/members/$(request.auth.uid));
    }

    // Check if a feed is public
    function isPublicCircle(feedId) {
      return get(/databases/$(database)/documents/v1/feeds/$(feedId)).data.visibility == 'public';
    }

    // --- /users Collection ---
    match /v1/users/{userId} {
      // READ: Any authenticated user can read public profile data
      allow get: if isAuthenticated();

      // UPDATE: Only the user themselves can update their profile
      allow update: if isOwner(userId);
      
      // CREATE: Handled by your auth/genkit flow
      allow create: if isOwner(userId);

      // --- /userFeeds Sub-collection ---
      match /feeds/{feedId} {
        // READ/LIST: Only the user can see their own list of feeds
        allow read: if isOwner(userId);
        
        // WRITE: Only Genkit flows (backend) should write this
        allow write: if false; 
      }
    }

    // --- /feeds Collection ---
    match /v1/feeds/{feedId} {
      // READ: 
      // - Any authenticated user can read a 'public' circle's data
      // - Only members can read a 'private' circle's data
      allow get: if isAuthenticated() && (isPublicCircle(feedId) || isMember(feedId));
      
      // LIST: (For Discovery)
      // Only allow listing public feeds
      allow list: if isAuthenticated() && request.query.where.visibility == 'public';

      // UPDATE: Only admins of the feed
      allow update: if isAuthenticated() && getRole(feedId) == 'admin';
      
      // CREATE: Handled by your genkit flow (backend), not by clients
      allow create: if false;
      
      // DELETE: Only admins
      allow delete: if isAuthenticated() && getRole(feedId) == 'admin';

      // --- /members Sub-collection ---
      match /members/{userId} {
        // READ/LIST: Only other members of the feed
        allow read: if isAuthenticated() && isMember(feedId);
        
        // CREATE: (Joining)
        // - Public feeds: Any auth'd user (handled by joinCircleFlow)
        // - Private feeds: Only admins/mods (inviting)
        // We'll deny client-side writes and force this through a flow
        allow write: if false;
        
        // UPDATE: (Change role) Only admins
        // DELETE: (Leave/Kick) User can leave, or admin can kick
        allow update: if isAuthenticated() && getRole(feedId) == 'admin';
        allow delete: if isAuthenticated() && (isOwner(userId) || getRole(feedId) == 'admin');
      }
    }
    
    // --- /posts Collection ---
    match /v1/posts/{postId} {
      // Get the feedId from the post document
      let feedId = resource.data.feedId;

      // READ: 
      // - If the feed is public, any auth'd user can read
      // - If the feed is private, only members can read
      allow get: if isAuthenticated() && (isPublicCircle(feedId) || isMember(feedId));
      
      // LIST:
      // Client can only list posts *for a specific feed*
      // And they must be a member or the feed must be public
      allow list: if isAuthenticated()
                    && request.query.where.feedId == feedId
                    && (isPublicCircle(feedId) || isMember(feedId));
                    
      // CREATE: Only members of the feed
      allow create: if isAuthenticated() && isMember(feedId);

      // UPDATE: Only the post author
      allow update: if isAuthenticated() && isOwner(resource.data.authorId);
      
      // DELETE: Post author or circle admin/mod
      allow delete: if isAuthenticated() && (isOwner(resource.data.authorId) || getRole(feedId) == 'admin' || getRole(feedId) == 'moderator');

      // --- /comments Sub-collection ---
      match /comments/{commentId} {
        // READ: Same rules as the parent post
        allow read: if isAuthenticated() && (isPublicCircle(feedId) || isMember(feedId));
        
        // CREATE: Only members of the feed
        allow create: if isAuthenticated() && isMember(feedId);
        
        // UPDATE: Only the comment author
        allow update: if isAuthenticated() && isOwner(resource.data.authorId);
        
        // DELETE: Comment author or circle admin/mod
        allow delete: if isAuthenticated() && (isOwner(resource.data.authorId) || getRole(feedId) == 'admin' || getRole(feedId) == 'moderator');
      }
    }
  }
}
